This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: packages/api/prisma/client/, packages/infra/src/.terraform, **/*/playwright-report, **/*.xml, doc/**/*.md, **/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  codeql/
    codeql-config.yml
  workflows/
    ci.yml
    codeql.yml
  dependabot.yml
.husky/
  commit-msg
  pre-commit
bin/
  codeplot.js
src/
  common/
    mcp-tool.ts
  components/
    AgentSelector.tsx
    App.tsx
    ChatWindow.tsx
    OptionSelector.tsx
  schemas/
    mcp-config.schema.ts
  services/
    agent/
      agent.interface.ts
      agent.service.ts
    config/
      config.interface.ts
      config.service.ts
    logger/
      logger.interface.ts
      logger.service.ts
    mcp/
      mcp.interface.ts
      mcp.service.ts
  utils/
    response-parser.ts
  container.ts
  index.ts
.env.example
.gitignore
.lintstagedrc.json
.npmrc-github
.prettierignore
.prettierrc
.prettierrc.json
.releaserc.json
commitlint.config.js
eslint.config.js
jest.config.js
LICENSE
package-github.json
package.json
setup.sh
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/OptionSelector.tsx">
import React, { useState } from 'react';
import { Box, Text, useInput } from 'ink';
import { ParsedOption } from '../utils/response-parser';
interface OptionSelectorProps {
  options: ParsedOption[];
  onSelect: (option: ParsedOption) => void;
  onCancel: () => void;
}
export const OptionSelector: React.FC<OptionSelectorProps> = ({ options, onSelect, onCancel }) => {
  const [selectedIndex, setSelectedIndex] = useState(0);
  useInput((input, key) => {
    if (key.upArrow || (key.tab && key.shift)) {
      setSelectedIndex(prev => (prev > 0 ? prev - 1 : options.length - 1));
    } else if (key.downArrow || key.tab) {
      setSelectedIndex(prev => (prev < options.length - 1 ? prev + 1 : 0));
    } else if (key.return) {
      onSelect(options[selectedIndex]);
    } else if (key.escape) {
      onCancel();
    } else if (input >= '1' && input <= '9') {
      const optionIndex = parseInt(input, 10) - 1;
      if (optionIndex >= 0 && optionIndex < options.length) {
        onSelect(options[optionIndex]);
      }
    }
  });
  return (
    <Box flexDirection="column" marginY={1}>
      <Box marginBottom={1}>
        <Text bold color="cyan">
          üí° Select an option:
        </Text>
      </Box>
      {options.map((option, index) => (
        <Box key={option.number}>
          <Box
            borderStyle={index === selectedIndex ? 'double' : 'single'}
            borderColor={
              option.isRecommended && index === selectedIndex
                ? 'yellow'
                : index === selectedIndex
                  ? 'cyan'
                  : option.isRecommended
                    ? 'yellow'
                    : 'gray'
            }
            paddingX={2}
            paddingY={0}
            minWidth={60}
          >
            <Box flexDirection="column">
              <Box>
                <Text bold color={index === selectedIndex ? 'cyan' : 'white'}>
                  {option.number}. {option.title}
                </Text>
                {option.isRecommended && (
                  <Text bold color="black" backgroundColor="yellow">
                    {' '}‚≠ê RECOMMENDED{' '}
                  </Text>
                )}
              </Box>
              {option.description && option.description.trim() && (
                <Box marginLeft={3} marginTop={0}>
                  <Text color={index === selectedIndex ? 'white' : 'gray'} dimColor>
                    {option.description.trim().split('\n')[0]}
                    {option.description.trim().split('\n').length > 1 && '...'}
                  </Text>
                </Box>
              )}
            </Box>
          </Box>
        </Box>
      ))}
    </Box>
  );
};
</file>

<file path="src/utils/response-parser.ts">
export interface ParsedOption {
  number: number;
  title: string;
  description: string;
  isRecommended: boolean;
}
</file>

<file path=".github/codeql/codeql-config.yml">
name: "CodeQL Config"
disable-default-queries: false
queries:
  - name: security-extended
    uses: security-extended
  - name: security-and-quality
    uses: security-and-quality
paths-ignore:
  - node_modules/**
  - coverage/**
  - dist/**
  - build/**
  - '**/*.test.js'
  - '**/*.spec.js'
  - docs/**
paths:
  - src/**
languages:
  - javascript
</file>

<file path="src/common/mcp-tool.ts">
export interface McpTool {
  serverName: string;
  toolName: string;
  description?: string;
  inputSchema: Record<string, unknown>;
}
</file>

<file path="src/components/AgentSelector.tsx">
import React from 'react';
import SelectInput from 'ink-select-input';
import { Box, Text } from 'ink';
interface AgentSelectorProps {
  onSelect: (agent: 'dev' | 'pm') => void;
}
interface AgentItem {
  label: string;
  value: 'dev' | 'pm';
}
const items: AgentItem[] = [
  { label: 'Plan a feature implementation (Developer Agent)', value: 'dev' },
  { label: 'Create a Product Requirements Document (PM Agent)', value: 'pm' },
];
export const AgentSelector: React.FC<AgentSelectorProps> = ({ onSelect }) => {
  const handleSelect = (item: AgentItem) => {
    onSelect(item.value);
  };
  return (
    <Box flexDirection="column">
      <Text>What would you like to do?</Text>
      <SelectInput items={items} onSelect={handleSelect} />
    </Box>
  );
};
</file>

<file path="src/components/ChatWindow.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import { Box, Text, useApp } from 'ink';
import TextInput from 'ink-text-input';
import Gradient from 'ink-gradient';
import BigText from 'ink-big-text';
import { IAgentService } from '../services/agent/agent.interface';
import { OptionSelector } from './OptionSelector';
import { ParsedOption } from '../utils/response-parser';
interface ChatWindowProps {
  agentService: IAgentService;
  onExit: () => void;
}
interface Message {
  sender: 'user' | 'agent' | 'system' | 'thought';
  content: string;
}
const senderDisplay = {
  user: { emoji: 'üë§', color: '#00FF7F', name: 'You' },
  agent: { emoji: 'ü§ñ', color: '#00BFFF', name: 'Agent' },
  system: { emoji: '‚öôÔ∏è', color: '#FFD700', name: 'System' },
  thought: { emoji: 'ü§î', color: '#FFA500', name: 'Thinking' },
};
const LoadingIndicator = () => {
  const [dots, setDots] = useState('');
  useEffect(() => {
    let dotCount = 0;
    const animate = () => {
      dotCount = (dotCount + 1) % 4;
      setDots('.'.repeat(dotCount));
      setTimeout(animate, 300);
    };
    const timeoutId = setTimeout(animate, 300);
    return () => clearTimeout(timeoutId);
  }, []);
  return <Text>Thinking{dots}</Text>;
};
export function ChatWindow({ agentService, onExit }: ChatWindowProps) {
  const { exit } = useApp();
  const [history, setHistory] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showOptions, setShowOptions] = useState(false);
  const [currentOptions, setCurrentOptions] = useState<ParsedOption[]>([]);
  const [isWaitingForHuman, setIsWaitingForHuman] = useState(false);
  const [humanInput, setHumanInput] = useState('');
  const threadId = useMemo(() => Math.random().toString(36).substring(7), []);
  useEffect(() => {
    setHistory([
      {
        sender: 'system',
        content:
          'Welcome to CodePlot! Your AI-powered development assistant. How can I help you today?',
      },
    ]);
  }, []);
  const [optionsQuestion, setOptionsQuestion] = useState('');
  const processStream = async (stream: AsyncGenerator<{ type: string; content: string }>) => {
    let fullResponse = '';
    let agentMessageIndex = -1;
    for await (const chunk of stream) {
      if (chunk.type === 'thinking' || chunk.type === 'tool_call') {
        setHistory(prev => [...prev, { sender: 'thought', content: chunk.content }]);
      } else if (chunk.type === 'agent') {
        if (agentMessageIndex === -1) {
          setHistory(prev => {
            const newHistory: Message[] = [...prev, { sender: 'agent', content: '' }];
            agentMessageIndex = newHistory.length - 1;
            return newHistory;
          });
        }
        fullResponse += chunk.content;
        setHistory(prev => {
          const newHistory = [...prev];
          if (newHistory[agentMessageIndex]) {
            newHistory[agentMessageIndex] = {
              ...newHistory[agentMessageIndex],
              content: fullResponse,
            };
          }
          return newHistory;
        });
      } else if (chunk.type === 'human_input_required') {
        setHistory(prev => [...prev, { sender: 'agent', content: chunk.content }]);
        setOptionsQuestion(chunk.content);
        setIsWaitingForHuman(true);
        setIsLoading(false);
        return;
      } else if (chunk.type === 'user_choice_required') {
        const { question, options } = JSON.parse(chunk.content);
        setHistory(prev => [...prev, { sender: 'agent', content: question }]);
        const parsedOptions: ParsedOption[] = options.map((opt: any, index: number) => ({
          ...opt,
          number: index + 1,
        }));
        setOptionsQuestion(question);
        setCurrentOptions(parsedOptions);
        setShowOptions(true);
        setIsLoading(false);
        return;
      }
    }
    setIsLoading(false);
  };
  const [isFirstMessage, setIsFirstMessage] = useState(true);
  const handleSumbit = async () => {
    if (!input) return;
    if (input.toLowerCase() === 'exit') {
      onExit();
      exit();
      return;
    }
    const userMessage: Message = { sender: 'user', content: input };
    let currentHistory: Message[] = [...history, userMessage];
    if (isFirstMessage) {
      currentHistory = [...currentHistory, { sender: 'system', content: 'Analyzing codebase...' }];
      setIsFirstMessage(false);
    }
    setHistory(currentHistory);
    setInput('');
    setIsLoading(true);
    setShowOptions(false);
    const stream = agentService.stream(input, threadId);
    await processStream(stream);
  };
  const handleOptionSelect = async (option: ParsedOption) => {
    const optionText = option.title;
    setShowOptions(false);
    setOptionsQuestion('');
    const userMessage: Message = { sender: 'user', content: optionText };
    setHistory(prev => [...prev, userMessage]);
    setIsLoading(true);
    const stream = agentService.stream(optionText, threadId);
    await processStream(stream);
  };
  const handleOptionCancel = () => {
    setShowOptions(false);
  };
  const handleHumanInputSubmit = async () => {
    if (!humanInput) return;
    const userMessage: Message = { sender: 'user', content: humanInput };
    setHistory(prev => [...prev, userMessage]);
    setHumanInput('');
    setIsLoading(true);
    setIsWaitingForHuman(false);
    const stream = agentService.stream(humanInput, threadId);
    await processStream(stream);
  };
  return (
    <Box flexDirection="column" flexGrow={1} padding={1}>
      <Gradient name="rainbow">
        <BigText text="CodePlot" align="center" font="block" />
      </Gradient>
      <Box flexDirection="column" flexGrow={1} borderStyle="round" padding={1}>
        {history.map((message, index) => (
          <Box key={index} flexDirection="column" marginBottom={1}>
            <Text bold color={senderDisplay[message.sender].color}>
              {senderDisplay[message.sender].emoji} {senderDisplay[message.sender].name}
            </Text>
            <Box marginLeft={3}>
              <Text>{message.content}</Text>
            </Box>
          </Box>
        ))}
        {isLoading && (
          <Box marginLeft={3}>
            <Text color="gray">
              <LoadingIndicator />
            </Text>
          </Box>
        )}
      </Box>
      {isWaitingForHuman ? (
        <Box flexDirection="column" marginTop={1}>
          <Text bold color="yellow">
            {optionsQuestion}
          </Text>
          <Box borderStyle="single" paddingX={1}>
            <Text>‚Ä∫ </Text>
            <TextInput
              value={humanInput}
              onChange={setHumanInput}
              onSubmit={handleHumanInputSubmit}
            />
          </Box>
        </Box>
      ) : showOptions && currentOptions.length > 0 ? (
        <Box flexDirection="column" marginY={1}>
          <Box marginBottom={1}>
            <Text bold color="yellow">
              {optionsQuestion}
            </Text>
          </Box>
          <OptionSelector
            options={currentOptions}
            onSelect={handleOptionSelect}
            onCancel={handleOptionCancel}
          />
        </Box>
      ) : (
        <Box marginTop={1} borderStyle="single" paddingX={1}>
          <Text>‚Ä∫ </Text>
          <TextInput value={input} onChange={setInput} onSubmit={handleSumbit} />
        </Box>
      )}
      <Box marginTop={1} justifyContent="center">
        <Box flexDirection="column" alignItems="center">
          {showOptions && (
            <Box marginBottom={1}>
              <Text color="gray" dimColor>
                ‚Üë/‚Üì Navigate ‚Ä¢ Enter Select ‚Ä¢ 1-{currentOptions.length} Quick select ‚Ä¢ Esc Cancel ‚Ä¢
                Type your own message
              </Text>
            </Box>
          )}
          <Text color="gray" dimColor>
            Type "exit" to quit
          </Text>
        </Box>
      </Box>
    </Box>
  );
}
</file>

<file path="src/schemas/mcp-config.schema.ts">
export interface McpServer {
  name: string;
  command: string;
  args?: string[];
  enabled: boolean;
}
export interface McpConfig {
  servers: McpServer[];
}
export interface McpServerFileFormat {
  command: string;
  args?: string[];
  enabled?: boolean;
}
export interface McpConfigFileFormat {
  servers?: McpServer[];
  mcpServers?: Record<string, McpServerFileFormat>;
}
</file>

<file path="src/services/agent/agent.interface.ts">
export interface IAgentService {
  initialize(agentType: 'dev' | 'pm', tools: any[]): Promise<void>;
  stream(input: string, threadId: string): AsyncGenerator<{ type: string; content: string }>;
}
export const AgentServiceToken = Symbol('IAgentService');
</file>

<file path="src/services/config/config.interface.ts">
import { McpConfig } from '../../schemas/mcp-config.schema';
export interface IConfigService {
  loadConfig(): Promise<McpConfig>;
  getMcpConfig(): McpConfig;
}
</file>

<file path="src/services/config/config.service.ts">
import { inject, singleton } from 'tsyringe';
import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import type { IConfigService } from './config.interface';
import type { ILoggerService } from '../logger/logger.interface';
import { McpConfig, McpServer, McpConfigFileFormat } from '../../schemas/mcp-config.schema';
@singleton()
export class ConfigService implements IConfigService {
  private mcpConfig: McpConfig = { servers: [] };
  constructor(@inject('ILoggerService') private readonly logger: ILoggerService) {}
  public getMcpConfig(): McpConfig {
    return this.mcpConfig;
  }
  public async loadConfig(): Promise<McpConfig> {
    const globalConfigPath = path.join(os.homedir(), '.codeplot', 'mcp-config.json');
    const projectConfigPath = path.join(process.cwd(), '.codeplot', 'mcp-config.json');
    const globalConfig = await this.readConfigFile(globalConfigPath);
    const projectConfig = await this.readConfigFile(projectConfigPath);
    this.mcpConfig = this.mergeConfigs(globalConfig, projectConfig);
    this.logger.info(
      `Final merged MCP config loaded with ${this.mcpConfig.servers.length} servers.`
    );
    return this.mcpConfig;
  }
  private async readConfigFile(filePath: string): Promise<McpConfig | undefined> {
    try {
      const data = await fs.readFile(filePath, 'utf-8');
      this.logger.info(`Successfully read config file: ${filePath}`);
      const rawConfig = JSON.parse(data) as McpConfigFileFormat;
      return this.normalizeConfig(rawConfig);
    } catch (error) {
      if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
        this.logger.debug(`Config file not found, skipping: ${filePath}`);
      } else {
        this.logger.error(`Error reading or parsing config file ${filePath}:`, error);
      }
      return undefined;
    }
  }
  private normalizeConfig(rawConfig: McpConfigFileFormat): McpConfig {
    const servers: McpServer[] = [];
    if (rawConfig.servers) {
      servers.push(...rawConfig.servers);
      this.logger.debug(`Found ${rawConfig.servers.length} servers in new format.`);
    }
    if (rawConfig.mcpServers) {
      const mcpServersCount = Object.keys(rawConfig.mcpServers).length;
      this.logger.debug(`Found ${mcpServersCount} servers in original mcpServers format.`);
      for (const [name, serverConfig] of Object.entries(rawConfig.mcpServers)) {
        servers.push({
          name,
          command: serverConfig.command,
          args: serverConfig.args,
          enabled: serverConfig.enabled ?? true,
        });
        this.logger.debug(`Converted server "${name}" from mcpServers format.`);
      }
    }
    return { servers };
  }
  private mergeConfigs(globalConfig?: McpConfig, projectConfig?: McpConfig): McpConfig {
    if (!globalConfig && !projectConfig) {
      this.logger.warn('No global or project MCP config files found.');
      return { servers: [] };
    }
    const serverMap = new Map<string, McpServer>();
    if (globalConfig?.servers) {
      globalConfig.servers.forEach(server => serverMap.set(server.name, server));
      this.logger.debug(`Loaded ${serverMap.size} servers from global config.`);
    }
    if (projectConfig?.servers) {
      projectConfig.servers.forEach(server => {
        if (serverMap.has(server.name)) {
          this.logger.info(
            `Overriding global server config with project config for: ${server.name}`
          );
        } else {
          this.logger.info(`Adding new server from project config: ${server.name}`);
        }
        serverMap.set(server.name, server);
      });
    }
    return { servers: Array.from(serverMap.values()) };
  }
}
</file>

<file path="src/services/logger/logger.interface.ts">
export interface ILoggerService {
  info(message: string, ...meta: unknown[]): void;
  warn(message: string, ...meta: unknown[]): void;
  error(message: string, ...meta: unknown[]): void;
  debug(message: string, ...meta: unknown[]): void;
  silenceConsole(): void;
}
</file>

<file path="src/services/logger/logger.service.ts">
import { singleton } from 'tsyringe';
import winston from 'winston';
import 'winston-daily-rotate-file';
import { ILoggerService } from './logger.interface';
@singleton()
export class LoggerService implements ILoggerService {
  private readonly logger: winston.Logger;
  constructor() {
    const isDebug = process.argv.includes('--debug');
    const consoleTransport = new winston.transports.Console({
      level: isDebug ? 'debug' : 'info',
      format: winston.format.combine(winston.format.colorize(), winston.format.simple()),
    });
    const fileTransport = new winston.transports.DailyRotateFile({
      level: 'debug',
      filename: 'logs/codeplot-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
    });
    this.logger = winston.createLogger({
      transports: [consoleTransport, fileTransport],
    });
  }
  public info(message: string, ...meta: unknown[]): void {
    this.logger.info(message, meta);
  }
  public warn(message: string, ...meta: unknown[]): void {
    this.logger.warn(message, meta);
  }
  public error(message: string, ...meta: unknown[]): void {
    this.logger.error(message, meta);
  }
  public debug(message: string, ...meta: unknown[]): void {
    this.logger.debug(message, meta);
  }
}
</file>

<file path="src/services/mcp/mcp.interface.ts">
import { McpTool } from '../../common/mcp-tool';
export interface IMcpService {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  getTools(): McpTool[];
  callTool(toolName: string, args: unknown): Promise<unknown>;
}
</file>

<file path=".env.example">
# Gemini API Key
# Get your API key from: https://aistudio.google.com/
GEMINI_API_KEY=your_gemini_api_key_here

# Optional: Default project path
# DEFAULT_PROJECT_PATH=/path/to/your/project

# Optional: Default output directory for ADRs
# DEFAULT_OUTPUT_DIR=./docs/adrs
</file>

<file path=".prettierignore">
node_modules/
coverage/
dist/
*.min.js
*.lock
package-lock.json
CHANGELOG.md
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
</file>

<file path=".prettierrc.json">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
</file>

<file path=".releaserc.json">
{
  "branches": [
    "main",
    {
      "name": "beta",
      "prerelease": true
    }
  ],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/npm",
    "@semantic-release/github",
    [
      "@semantic-release/git",
      {
        "assets": ["package.json", "CHANGELOG.md"],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ]
  ]
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Matheus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package-github.json">
{
  "name": "@matheusrezende/codeplot",
  "version": "1.4.0",
  "description": "Interactive CLI tool for feature planning and ADR generation using Gemini 2.5 Pro",
  "type": "module",
  "main": "src/index.js",
  "bin": {
    "codeplot": "./src/index.js"
  },
  "keywords": [
    "cli",
    "codeplot",
    "architecture",
    "adr",
    "feature-planning",
    "gemini",
    "ai",
    "planning",
    "development",
    "plotting"
  ],
  "author": "Matheus",
  "license": "MIT",
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "chalk": "^5.3.0",
    "child_process": "^1.0.2",
    "commander": "^14.0.0",
    "fs-extra": "^11.2.0",
    "inquirer": "^12.6.3",
    "ora": "^8.1.0"
  },
  "engines": {
    "node": ">=20.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/matheusrezende/codeplot.git"
  },
  "homepage": "https://github.com/matheusrezende/codeplot#readme",
  "bugs": {
    "url": "https://github.com/matheusrezende/codeplot/issues"
  },
  "publishConfig": {
    "access": "public",
    "registry": "https://npm.pkg.github.com"
  },
  "files": ["src/", "README.md", "LICENSE"]
}
</file>

<file path="setup.sh">
echo "üìä  Codeplot Setup"
echo "========================"
if ! command -v node &> /dev/null; then
    echo "‚ùå Node.js is not installed"
    echo "üì• Please install Node.js (>=18.0.0) from:"
    echo "   https://nodejs.org/"
    echo "   or use a version manager like nvm:"
    echo "   curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash"
    echo "   nvm install --lts"
    exit 1
fi
echo "‚úÖ Node.js is installed: $(node --version)"
if ! command -v npm &> /dev/null; then
    echo "‚ùå npm is not available"
    exit 1
fi
echo "‚úÖ npm is available: $(npm --version)"
echo "üì¶ Installing dependencies..."
npm install
if [ $? -eq 0 ]; then
    echo "‚úÖ Dependencies installed successfully"
else
    echo "‚ùå Failed to install dependencies"
    exit 1
fi
echo "üîó Making CLI globally available..."
npm link
if [ $? -eq 0 ]; then
    echo "‚úÖ CLI linked successfully"
else
    echo "‚ùå Failed to link CLI"
    exit 1
fi
echo ""
echo "üéâ Setup completed!"
echo ""
echo "Next steps:"
echo "1. Set your Gemini API key:"
echo "   export GEMINI_API_KEY='your_api_key_here'"
echo ""
echo "2. Test the CLI:"
echo "   codeplot init"
echo ""
echo "3. Plan a feature:"
echo "   codeplot plan --project-path /path/to/your/project"
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "monday"
      time: "09:00"
      timezone: "UTC"
    open-pull-requests-limit: 10
    reviewers:
      - "matheusrezende"
    assignees:
      - "matheusrezende"
    commit-message:
      prefix: "chore(deps)"
      include: "scope"
    labels:
      - "dependencies"
      - "automated"
    ignore:
      - dependency-name: "eslint"
        update-types: ["version-update:semver-major"]
    groups:
      development-dependencies:
        dependency-type: "development"
        patterns:
          - "@commitlint/*"
          - "@semantic-release/*"
          - "eslint*"
          - "prettier"
          - "husky"
          - "lint-staged"
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "monday"
      time: "09:00"
      timezone: "UTC"
    open-pull-requests-limit: 5
    reviewers:
      - "matheusrezende"
    assignees:
      - "matheusrezende"
    commit-message:
      prefix: "chore(ci)"
      include: "scope"
    labels:
      - "github-actions"
      - "automated"
</file>

<file path=".husky/commit-msg">
npx --no -- commitlint --edit $1
</file>

<file path=".husky/pre-commit">
npm run precommit
</file>

<file path="bin/codeplot.js">
#!/usr/bin/env node
import { spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { existsSync } from 'fs';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const mainFile = join(__dirname, '..', 'src', 'index.ts');
const localTsx = join(__dirname, '..', 'node_modules', '.bin', 'tsx');
const tsxCommand = existsSync(localTsx) ? localTsx : 'tsx';
const child = spawn(tsxCommand, [mainFile, ...process.argv.slice(2)], {
  stdio: 'inherit',
  cwd: process.cwd(),
});
child.on('close', code => {
  process.exit(code);
});
child.on('error', err => {
  if (err.code === 'ENOENT') {
    console.error(
      'Error: tsx is not available. This should not happen in a properly installed package.'
    );
    console.error('Please report this issue at: https://github.com/matheusrezende/codeplot/issues');
    process.exit(1);
  } else {
    console.error('Error starting application:', err.message);
    process.exit(1);
  }
});
</file>

<file path="src/components/App.tsx">
import React, { useState, useEffect } from 'react';
import { Text, useApp } from 'ink';
import { IAgentService } from '../services/agent/agent.interface';
import { ILoggerService } from '../services/logger/logger.interface';
import { IMcpService } from '../services/mcp/mcp.interface';
import { AgentSelector } from './AgentSelector';
import { ChatWindow } from './ChatWindow';
type AppState = 'selecting-agent' | 'initializing' | 'chatting' | 'error';
interface AppProps {
  logger: ILoggerService;
  mcpService: IMcpService;
  agentService: IAgentService;
}
export function App({ logger, mcpService, agentService }: AppProps) {
  const { exit } = useApp();
  const [appState, setAppState] = useState<AppState>('selecting-agent');
  const [selectedAgent, setSelectedAgent] = useState<'dev' | 'pm' | null>(null);
  useEffect(() => {
    if (appState === 'initializing' && selectedAgent) {
      const initialize = async () => {
        logger.info(`User selected the ${selectedAgent === 'dev' ? 'Developer' : 'PM'} Agent.`);
        try {
          await mcpService.connect();
          const tools = mcpService.getTools();
          await agentService.initialize(selectedAgent, tools);
          logger.info('Agent initialized successfully.');
          setAppState('chatting');
        } catch (error) {
          logger.error(`Failed to initialize agent: ${error}`, error);
          setAppState('error');
        }
      };
      initialize();
    }
  }, [appState, selectedAgent, agentService, logger, mcpService]);
  const handleAgentSelect = (agentType: 'dev' | 'pm') => {
    setSelectedAgent(agentType);
    setAppState('initializing');
  };
  if (appState === 'selecting-agent') {
    return <AgentSelector onSelect={handleAgentSelect} />;
  }
  if (appState === 'initializing') {
    return <Text>Initializing agent...</Text>;
  }
  if (appState === 'chatting') {
    return <ChatWindow agentService={agentService} onExit={exit} />;
  }
  if (appState === 'error') {
    return <Text color="red">An error occurred during initialization. Please check the logs.</Text>;
  }
  return <Text>Unknown application state.</Text>;
}
</file>

<file path="src/services/agent/agent.service.ts">
import { inject, singleton } from 'tsyringe';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
import { DynamicStructuredTool } from 'langchain/tools';
import { AIMessage, BaseMessage, HumanMessage, SystemMessage } from '@langchain/core/messages';
import { StateGraph, END, MemorySaver } from '@langchain/langgraph';
import { ToolNode } from '@langchain/langgraph/prebuilt';
import { IAgentService } from './agent.interface';
import type { ILoggerService } from '../logger/logger.interface';
import type { IMcpService } from '../mcp/mcp.interface';
import { McpTool } from '../../common/mcp-tool';
interface AgentState {
  messages: BaseMessage[];
}
const DEV_AGENT_PROMPT = `
You are an expert senior software architect. Your goal is to help the user create a new feature by producing an Architecture Decision Record (ADR) and an implementation plan.
**Your Process:**
You must follow these steps in order:
1.  **Analyze Codebase:** On the user's first message, you MUST call the 'pack_codebase' tool with the current working directory to get context.
2.  **Gather & Clarify:** Understand the user's high-level goal. Ask clarifying questions until the goal is clear.
3.  **Validate:** Cross-reference the user's request with the provided codebase context to identify conflicts or integration points.
4.  **Propose Solutions:** Guide the user to a final architecture.
**Interaction Rules:**
- Ask ONLY ONE question at a time.
- When you need the user to make a decision, you MUST call the \`requestUserChoice\` tool. Provide a clear question and at least two distinct options. You MUST set \`isRecommended\` to true for one of the options.
- Wait for the user's response before proceeding.
`;
const PM_AGENT_PROMPT = `
You are an expert product manager. Your goal is to help the user define a new feature by producing a Product Requirements Document (PRD).
**Your Process:**
You must follow these steps:
1.  **Analyze Codebase:** On the user's first message, you MUST call the 'pack_codebase' tool with the current working directory to get context.
2.  **Define Problem:** Understand the user problem this feature solves.
3.  **Define Goals:** Clarify the success metrics and goals.
4.  **Define Requirements:** Detail the user stories and functional requirements.
**Interaction Rules:**
- Ask ONLY ONE question at a time.
- When you need the user to make a decision, you MUST call the \`requestUserChoice\` tool. Provide a clear question and at least two distinct options. You MUST set \`isRecommended\` to true for one of the options.
- Wait for the user's response before proceeding.
`;
@singleton()
export class AgentService implements IAgentService {
  private runnable: any;
  constructor(
    @inject('ILoggerService') private readonly logger: ILoggerService,
    @inject('IMcpService') private readonly mcpService: IMcpService
  ) {}
  public async initialize(agentType: 'dev' | 'pm', tools: McpTool[]): Promise<void> {
    this.logger.info(`Initializing agent of type: ${agentType}`);
    this.logger.info(`Available tools: ${tools.length}`);
    const model = new ChatGoogleGenerativeAI({
      model: 'gemini-2.5-pro',
      maxOutputTokens: 2048,
      apiKey: process.env.GEMINI_API_KEY,
    });
    const dynamicTools = tools.map(
      tool =>
        new DynamicStructuredTool({
          name: tool.toolName,
          description: tool.description!,
          schema: tool.inputSchema as any,
          func: async (args: any) => {
            try {
              this.logger.debug(`Calling tool ${tool.toolName} with args:`, args);
              const result = await this.mcpService.callTool(tool.toolName, args);
              return JSON.stringify(result);
            } catch (error) {
              this.logger.error(`Error calling tool ${tool.toolName}:`, error);
              return `Error: ${error instanceof Error ? error.message : 'Unknown error'}`;
            }
          },
        })
    );
    const humanTool = new DynamicStructuredTool({
      name: 'ask_human',
      description:
        'Asks the human for input. Use this when you need clarification or feedback before proceeding.',
      schema: {
        type: 'object',
        properties: {
          question: {
            type: 'string',
            description: 'The question to ask the human.',
          },
        },
        required: ['question'],
      } as any,
      func: async () => 'Pausing for human input.',
    });
    const requestUserChoiceTool = new DynamicStructuredTool({
      name: 'requestUserChoice',
      description:
        'Asks the user to make a choice from a set of options. Use this when you need user input to proceed.',
      schema: {
        type: 'object',
        properties: {
          question: {
            type: 'string',
            description: 'The question to ask the user.',
          },
          options: {
            type: 'array',
            description: 'An array of options for the user to choose from.',
            items: {
              type: 'object',
              properties: {
                title: { type: 'string', description: 'The short title for the option.' },
                description: {
                  type: 'string',
                  description: 'A detailed description of the option.',
                },
                isRecommended: {
                  type: 'boolean',
                  description: 'Whether this option is recommended.',
                },
              },
              required: ['title', 'description'],
            },
          },
        },
        required: ['question', 'options'],
      } as any,
      func: async () => 'Pausing for user choice.',
    });
    const allTools: DynamicStructuredTool[] = [...dynamicTools, humanTool, requestUserChoiceTool];
    const modelWithTools = model.bindTools(allTools);
    const toolNode = new ToolNode<AgentState>(allTools);
    const memory = new MemorySaver();
    const systemPrompt = agentType === 'dev' ? DEV_AGENT_PROMPT : PM_AGENT_PROMPT;
    const systemMessage = new SystemMessage(systemPrompt);
    const graph = new StateGraph<AgentState>({
      channels: {
        messages: {
          value: (x: BaseMessage[], y: BaseMessage[]) => x.concat(y),
          default: () => [systemMessage],
        },
      },
    })
      .addNode('agent', async state => {
        const response = await modelWithTools.invoke(state.messages);
        return { messages: [response] };
      })
      .addNode('tools', toolNode)
      .addNode('human_in_the_loop', async () => {
        return {};
      })
      .setEntryPoint('agent');
    graph.addConditionalEdges('agent', state => {
      const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
      if (lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {
        if (
          lastMessage.tool_calls.some(
            tc => tc.name === 'ask_human' || tc.name === 'requestUserChoice'
          )
        ) {
          return 'human_in_the_loop';
        }
        return 'tools';
      }
      return END;
    });
    graph.addEdge('tools', 'agent');
    graph.addEdge('human_in_the_loop', 'agent');
    this.runnable = graph.compile({ checkpointer: memory });
    this.logger.info('Agent initialized successfully.');
  }
  public async *stream(
    input: string,
    threadId: string
  ): AsyncGenerator<{ type: string; content: string }> {
    if (!this.runnable) {
      throw new Error('Agent not initialized. Call initialize() first.');
    }
    this.logger.debug(`Starting stream for input: ${input}`);
    const initialState: AgentState = {
      messages: [new HumanMessage(input)],
    };
    const stream = await this.runnable.stream(initialState, {
      configurable: { thread_id: threadId },
    });
    let mostRecentStateWithMessages: AgentState | null = null;
    for await (const step of stream) {
      const stepName = Object.keys(step)[0];
      if (stepName === '__end__') continue;
      const stepState = Object.values(step)[0] as AgentState;
      this.logger.debug(`Executing step: ${stepName}`);
      if (stepState.messages && Array.isArray(stepState.messages)) {
        mostRecentStateWithMessages = stepState;
      }
      const stateToUse = mostRecentStateWithMessages;
      if (stepName === 'agent') {
        const lastMessage = stepState.messages[stepState.messages.length - 1] as AIMessage;
        if (lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {
          yield { type: 'thinking', content: 'Thinking...' };
          for (const toolCall of lastMessage.tool_calls) {
            yield {
              type: 'tool_call',
              content: `Calling: ${toolCall.name}`,
            };
          }
        }
        if (lastMessage.content && typeof lastMessage.content === 'string') {
          yield { type: 'agent', content: lastMessage.content };
        }
      } else if (stepName === 'human_in_the_loop') {
        if (!stateToUse) {
          this.logger.error('Entered human_in_the_loop without a preceding agent state.');
          return;
        }
        const lastMessage = stateToUse.messages[stateToUse.messages.length - 1] as AIMessage;
        const userChoiceToolCall = lastMessage.tool_calls?.find(
          tc => tc.name === 'requestUserChoice'
        );
        if (userChoiceToolCall?.args) {
          yield { type: 'user_choice_required', content: JSON.stringify(userChoiceToolCall.args) };
          return;
        }
        const humanQueryToolCall = lastMessage.tool_calls?.find(tc => tc.name === 'ask_human');
        if (humanQueryToolCall?.args) {
          const question = humanQueryToolCall.args.question;
          yield { type: 'human_input_required', content: question };
          return;
        }
      } else if (stepName === 'tools') {
        if (!stateToUse) {
          this.logger.error('In tools node, but no state with messages is available.');
          return;
        }
        const lastMessage = stateToUse.messages[stateToUse.messages.length - 1];
        if (Array.isArray(lastMessage.content)) {
          for (const toolOutput of lastMessage.content) {
            yield { type: 'tool', content: JSON.stringify(toolOutput, null, 2) };
          }
        }
      }
    }
  }
}
</file>

<file path="src/services/mcp/mcp.service.ts">
import { inject, singleton } from 'tsyringe';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { IMcpService } from './mcp.interface';
import type { ILoggerService } from '../logger/logger.interface';
import type { IConfigService } from '../config/config.interface';
import { McpTool } from '../../common/mcp-tool';
import { McpServer } from '../../schemas/mcp-config.schema';
@singleton()
export class McpService implements IMcpService {
  private clients: Map<string, Client> = new Map();
  private tools: McpTool[] = [];
  constructor(
    @inject('ILoggerService') private readonly logger: ILoggerService,
    @inject('IConfigService') private readonly configService: IConfigService
  ) {}
  public async connect(): Promise<void> {
    const config = await this.configService.loadConfig();
    const enabledServers = config.servers.filter(server => server.enabled);
    this.logger.info(`Connecting to ${enabledServers.length} enabled MCP servers...`);
    for (const server of enabledServers) {
      await this.connectToServer(server);
    }
  }
  public async disconnect(): Promise<void> {
    this.logger.info('Disconnecting from all MCP servers...');
    const disconnectPromises = Array.from(this.clients.entries()).map(async ([name, client]) => {
      try {
        await client.close();
        this.logger.info(`Disconnected from server: ${name}`);
      } catch (error) {
        this.logger.error(`Error disconnecting from server ${name}:`, error);
      }
    });
    await Promise.allSettled(disconnectPromises);
    this.clients.clear();
    this.tools = [];
  }
  public getTools(): McpTool[] {
    return this.tools;
  }
  public async callTool(toolName: string, args: unknown): Promise<unknown> {
    const tool = this.tools.find(t => t.toolName === toolName);
    if (!tool) {
      throw new Error(`Tool not found: ${toolName}`);
    }
    const client = this.clients.get(tool.serverName);
    if (!client) {
      throw new Error(`Client not found for server: ${tool.serverName}`);
    }
    try {
      this.logger.debug(`Calling tool ${toolName} with args:`, args);
      const toolArgs = args as Record<string, unknown>;
      const result = await client.callTool({
        name: toolName,
        arguments: toolArgs,
      });
      return result.content;
    } catch (error) {
      this.logger.error(`Error calling tool ${toolName} with args ${JSON.stringify(args)}:`, error);
      if (error && typeof error === 'object' && 'message' in error) {
        this.logger.error(`Error details: ${error.message}`);
      }
      throw error;
    }
  }
  private async connectToServer(server: McpServer): Promise<void> {
    try {
      this.logger.info(`Connecting to MCP server: ${server.name}`);
      const transport = new StdioClientTransport({
        command: server.command,
        args: server.args || [],
      });
      const client = new Client(
        {
          name: 'codeplot',
          version: '3.1.0',
        },
        {
          capabilities: {
            tools: {},
          },
        }
      );
      await client.connect(transport);
      this.clients.set(server.name, client);
      this.logger.info(`Successfully connected to MCP server: ${server.name}`);
      await this.discoverTools(server.name, client);
    } catch (error) {
      this.logger.error(`Failed to connect to MCP server ${server.name}:`, error);
      throw error;
    }
  }
  private async discoverTools(serverName: string, client: Client): Promise<void> {
    try {
      const result = await client.listTools();
      const discoveredTools = result.tools.map((tool: Tool) => ({
        serverName,
        toolName: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema,
      }));
      this.tools.push(...discoveredTools);
      this.logger.info(`Discovered ${discoveredTools.length} tools from server: ${serverName}`);
      discoveredTools.forEach(tool => {
        this.logger.debug(
          `Tool ${tool.toolName} schema:`,
          JSON.stringify(tool.inputSchema, null, 2)
        );
      });
    } catch (error) {
      this.logger.error(`Error discovering tools from ${serverName}:`, error);
    }
  }
}
</file>

<file path=".lintstagedrc.json">
{
  "*.{js,ts,tsx}": ["eslint --fix", "prettier --write"],
  "*.{md,json}": ["prettier --write"]
}
</file>

<file path=".npmrc-github">
@matheusrezende:registry=https://npm.pkg.github.com
//npm.pkg.github.com/:_authToken=${NODE_AUTH_TOKEN}
</file>

<file path="commitlint.config.js">
export default {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'build',
        'chore',
        'ci',
        'docs',
        'feat',
        'fix',
        'perf',
        'refactor',
        'revert',
        'style',
        'test',
      ],
    ],
    'subject-case': [2, 'never', ['start-case', 'pascal-case', 'upper-case']],
    'subject-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],
    'header-max-length': [2, 'always', 100],
    'body-max-line-length': [1, 'always', 300],
  },
  ignores: [
    message => message.startsWith('chore(release):'),
  ],
};
</file>

<file path="eslint.config.js">
import js from '@eslint/js';
import tsParser from '@typescript-eslint/parser';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import prettierConfig from 'eslint-config-prettier';
export default [
  js.configs.recommended,
  {
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: {
        console: 'readonly',
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        global: 'readonly',
        setImmediate: 'readonly',
        clearImmediate: 'readonly',
        setTimeout: 'readonly',
        clearTimeout: 'readonly',
        jest: 'readonly',
        describe: 'readonly',
        test: 'readonly',
        it: 'readonly',
        expect: 'readonly',
        beforeEach: 'readonly',
        afterEach: 'readonly',
        beforeAll: 'readonly',
        afterAll: 'readonly',
      },
    },
    rules: {
      'no-unused-vars': ['error', { argsIgnorePattern: '^_', varsIgnorePattern: '^_' }],
      'no-console': 'off',
      'prefer-const': 'error',
      'no-var': 'error',
      'object-shorthand': 'error',
      'prefer-arrow-callback': 'error',
      'no-duplicate-imports': 'error',
    },
  },
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        project: './tsconfig.json',
      },
    },
    plugins: {
      '@typescript-eslint': tsPlugin,
    },
    rules: {
      ...tsPlugin.configs.recommended.rules,
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_', varsIgnorePattern: '^_' },
      ],
      '@typescript-eslint/explicit-function-return-type': 'warn',
      '@typescript-eslint/no-explicit-any': 'warn',
      'prefer-const': 'error',
      'no-unused-vars': 'off',
    },
  },
  prettierConfig,
  {
    ignores: ['node_modules/', 'coverage/', 'dist/', '*.min.js'],
  },
];
</file>

<file path="jest.config.js">
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  transform: {
    '^.+\\.(ts|tsx)$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,ts}',
    '!src/index.{js,ts}',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  testMatch: ['**/__tests__/**/*.test.{js,ts}', '**/?(*.)+(spec|test).{js,ts}'],
  verbose: true,
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "sourceMap": false,
    "removeComments": true,
    "noEmitOnError": true,
    "isolatedModules": true,
    "verbatimModuleSyntax": false,
    "resolveJsonModule": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path=".github/workflows/codeql.yml">
name: "CodeQL"
on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '22 6 * * 1'
jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript' ]
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - name: Setup Volta
      uses: volta-cli/action@v4
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        config-file: ./.github/codeql/codeql-config.yml
        queries: security-extended,security-and-quality
    - name: Autobuild
      uses: github/codeql-action/autobuild@v3
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"
</file>

<file path="src/container.ts">
import { container } from 'tsyringe';
import { LoggerService } from './services/logger/logger.service';
import { ILoggerService } from './services/logger/logger.interface';
import { ConfigService } from './services/config/config.service';
import { IConfigService } from './services/config/config.interface';
import { McpService } from './services/mcp/mcp.service';
import { IMcpService } from './services/mcp/mcp.interface';
import { AgentService } from './services/agent/agent.service';
import { AgentServiceToken, IAgentService } from './services/agent/agent.interface';
container.registerSingleton<IAgentService>(AgentServiceToken, AgentService);
container.registerSingleton<IMcpService>('IMcpService', McpService);
container.registerSingleton<IConfigService>('IConfigService', ConfigService);
container.registerSingleton<ILoggerService>('ILoggerService', LoggerService);
export default container;
</file>

<file path="src/index.ts">
#!/usr/bin/env node
import 'reflect-metadata';
import { Command } from 'commander';
import React from 'react';
import { render } from 'ink';
import container from './container';
import { ILoggerService } from './services/logger/logger.interface';
import { IMcpService } from './services/mcp/mcp.interface';
import { AgentServiceToken, IAgentService } from './services/agent/agent.interface';
import { App } from './components/App';
const program = new Command();
program
  .version('0.0.1')
  .description('An agent-powered CLI for software development tasks.')
  .option('--debug', 'Enable debug logging');
program
  .command('plan')
  .description('Start a planning session with an AI agent.')
  .action(async () => {
    const logger = container.resolve<ILoggerService>('ILoggerService');
    const mcpService = container.resolve<IMcpService>('IMcpService');
    const agentService = container.resolve<IAgentService>(AgentServiceToken);
    let ctrlCCount = 0;
    const handleCtrlC = async () => {
      ctrlCCount++;
      console.log(`\nPress Ctrl+C again to exit (${ctrlCCount}/2)`);
      if (ctrlCCount >= 2) {
        console.log('\nExiting...');
        await mcpService.disconnect();
        process.exit(0);
      }
      setTimeout(() => {
        ctrlCCount = 0;
      }, 2000);
    };
    process.on('SIGINT', handleCtrlC);
    const app = render(React.createElement(App, { logger, mcpService, agentService }), {
      stdout: process.stderr,
    });
    process.on('exit', () => {
      mcpService.disconnect().catch(() => {
      });
      app.unmount();
    });
    await app.waitUntilExit();
  });
program.parse(process.argv);
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.local
.env.production

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
public

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Logs
logs
*.log

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# Repomix output files
repomix-output.txt

# Test ADR files
docs/

# Test coverage
coverage/
.nyc_output/

# Semantic release
.semantic-release/

# Husky
.husky/_/

# Local environment files
.env.local
.env.*.local

# Editor directories and files
.vscode/
!.vscode/extensions.json
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Linux
*~

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Yarn
yarn-error.log
.yarn/
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# pnpm
.pnpm-debug.log*

# Codeplot sessions
.codeplot/


# ConPort
context_portal/

repo.xml
</file>

<file path=".github/workflows/ci.yml">
name: CI/CD Pipeline
on:
  push:
    branches: [main, develop, beta]
  pull_request:
    branches: [main, develop]
env:
  NODE_VERSION: '22.17.0'
jobs:
  lint-and-format:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Volta
        uses: volta-cli/action@v4
      - name: Install dependencies
        run: npm ci
      - name: Run ESLint
        run: npm run lint
      - name: Check Prettier formatting
        run: npm run format:check
      - name: TypeScript type check
        run: npx tsc --noEmit
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20, 22]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Volta
        uses: volta-cli/action@v4
        with:
          node-version: ${{ matrix.node-version }}
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm run test:coverage
      - name: Upload coverage to Codecov
        if: matrix.node-version == 20
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./coverage/
          flags: unittests
          name: codecov-umbrella
  build-test:
    name: Build and Integration Test
    runs-on: ubuntu-latest
    needs: [lint-and-format, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Volta
        uses: volta-cli/action@v4
      - name: Install dependencies
        run: npm ci
      - name: Test CLI installation
        run: |
          npm link
          codeplot --version
          codeplot init
      - name: Test bin script directly
        run: |
          node bin/codeplot.js --version
          node bin/codeplot.js init
      - name: Test package.json validity
        run: npm pack --dry-run
  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Volta
        uses: volta-cli/action@v4
      - name: Install dependencies
        run: npm ci
      - name: Run security audit
        run: npm audit --audit-level=moderate
  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [lint-and-format, test, build-test, security]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
      repository-projects: write
      checks: write
      statuses: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN }}
      - name: Setup Volta
        uses: volta-cli/action@v4
        with:
          registry-url: 'https://registry.npmjs.org'
      - name: Install dependencies
        run: npm ci
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      - name: Release to NPM
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npm run semantic-release
      - name: Setup for GitHub Packages
        uses: volta-cli/action@v4
        with:
          registry-url: 'https://npm.pkg.github.com'
      - name: Prepare GitHub Package
        run: |
          VERSION=$(node -p "require('./package.json').version")
          node -e "const pkg = require('./package-github.json'); pkg.version = process.argv[1]; require('fs').writeFileSync('./package-github.json', JSON.stringify(pkg, null, 2));" "$VERSION"
          cp package-github.json package.json
          cp .npmrc-github .npmrc
      - name: Publish to GitHub Packages
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: npm publish --registry=https://npm.pkg.github.com
</file>

<file path="package.json">
{
  "name": "codeplot",
  "version": "3.1.0",
  "description": "Interactive CLI tool for feature planning and ADR generation using Gemini 2.5 Pro",
  "type": "module",
  "main": "bin/codeplot.js",
  "bin": {
    "codeplot": "./bin/codeplot.js"
  },
  "scripts": {
    "start": "tsx src/index.ts plan",
    "start:debug": "tsx src/index.ts plan --debug",
    "dev": "tsx --watch src/index.ts plan",
    "dev:debug": "tsx --watch src/index.ts plan --debug",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "test:watch": "node --experimental-vm-modules node_modules/.bin/jest --watch",
    "test:coverage": "node --experimental-vm-modules node_modules/.bin/jest --coverage",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "format": "prettier --write src/**/*.ts *.md *.json",
    "format:check": "prettier --check src/**/*.ts *.md *.json",
    "typecheck": "tsc --noEmit",
    "precommit": "lint-staged",
    "prepare": "husky install",
    "commitlint": "commitlint --edit --last",
    "semantic-release": "semantic-release",
    "validate": "npm run lint && npm run format:check && npm run test",
    "audit:fix": "npm audit fix",
    "audit:check": "npm audit --audit-level=moderate",
    "security:check": "npm run audit:check && npm run lint",
    "outdated:check": "npm outdated",
    "deps:update": "npm update && npm audit fix",
    "prepublishOnly": "npm run validate",
    "prepack": "npm run lint && npm run format:check"
  },
  "keywords": [
    "cli",
    "codeplot",
    "architecture",
    "adr",
    "feature-planning",
    "gemini",
    "ai",
    "planning",
    "development",
    "plotting"
  ],
  "author": "Matheus",
  "license": "MIT",
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@langchain/core": "^0.3.61",
    "@langchain/google-genai": "^0.2.14",
    "@langchain/langgraph": "^0.3.5",
    "@modelcontextprotocol/sdk": "^1.13.2",
    "chalk": "^5.3.0",
    "child_process": "^1.0.2",
    "commander": "^14.0.0",
    "fs-extra": "^11.2.0",
    "glob": "^11.0.3",
    "ink": "^6.0.1",
    "ink-big-text": "^2.0.0",
    "ink-gradient": "^3.0.0",
    "ink-select-input": "^6.2.0",
    "ink-spinner": "^5.0.0",
    "ink-text-input": "^6.0.0",
    "langchain": "^0.3.29",
    "marked": "^15.0.12",
    "marked-terminal": "^7.3.0",
    "ora": "^8.1.0",
    "react": "^19.1.0",
    "reflect-metadata": "^0.2.2",
    "tsx": "^4.20.3",
    "tsyringe": "^4.10.0",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0"
  },
  "devDependencies": {
    "@commitlint/cli": "^19.8.1",
    "@commitlint/config-conventional": "^19.8.1",
    "@eslint/js": "^9.29.0",
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/git": "^10.0.1",
    "@types/fs-extra": "^11.0.4",
    "@types/ink": "^0.5.2",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.0.7",
    "@types/react": "^19.1.8",
    "@typescript-eslint/eslint-plugin": "^8.35.0",
    "@typescript-eslint/parser": "^8.35.0",
    "eslint": "^9.29.0",
    "eslint-config-prettier": "^10.1.5",
    "husky": "^9.0.10",
    "jest": "^30.0.3",
    "lint-staged": "^16.1.2",
    "nodemon": "^3.1.4",
    "prettier": "^3.2.5",
    "semantic-release": "^24.2.5",
    "ts-jest": "^29.4.0",
    "typescript": "^5.8.3"
  },
  "engines": {
    "node": ">=20.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/matheusrezende/codeplot.git"
  },
  "homepage": "https://github.com/matheusrezende/codeplot#readme",
  "bugs": {
    "url": "https://github.com/matheusrezende/codeplot/issues"
  },
  "publishConfig": {
    "access": "public"
  },
  "files": [
    "bin/",
    "src/",
    "README.md",
    "LICENSE"
  ],
  "volta": {
    "node": "22.17.0",
    "npm": "10.9.2"
  }
}
</file>

</files>
